## Big O of RadixSort

기수 정렬 시간 및 공간 복잡도

| Time Complexity( Best ) | Time Complexity( Average ) | Time Complexity( Worst ) | Space Complexity |          
|:-----------------------:|:--------------------------:|:------------------------:|:----------------:|
|       **O( nk )**       |        **O( nk )**         |       **O( nk )**        |  **O( n + k )**  |


- 기수 정렬( Radix Sort )에는 약간의 논란과 논쟁의 여지가 존재한다


- 이 표기법은 일반적으로 인정되는 표기법이다


- 모든 시간 복잡도는 **O( nk )** 이다
  - n 은 정렬할 el 수, 정수의 수 이고,
  - k 는 이러한 수의 길이이다( word size or digit )
  - 따라서 수가 아주아주 길다면 이점을 고려하는 것이 중요하다
  - 무시할 수 있는 상수( k )가 아니다
  - 따라서, 아주 긴 수가 있으면 시간에 상당한 영향을 미친다


- 즉,
  - **n** : length of array
  - **k** : number of digits( average )


- 논란이 될 수 있는 이유는, **이론상에서는 비교 정렬들에 비해서는 상당히 좋을 수 있기 때문**이다
  - 비교정렬은 최상 및 평균이 **O( n log n )** 이기 때문이다


- 또한, 기수정렬 방식은 컴퓨터 메모리에 숫자가 저장되는 방식과 관련되어 있다


- 기수 정렬( Radix Sort )이 좋다는 주장
  - 모든 수가 고유하고, 무작위로 분산된 데이터를 다룰 경우에는 단순화되어 **k** 가 **log n** 이 된다
    - 컴퓨터가 숫자, 정보를 저장하는 방식 때문...
  - 즉, 기수정렬의 평균 케이스에서 **O( n log n )** 과 같이 효율적이라는 이야기가 된다


- 기수 정렬( Radix Sort )이 좋지 않다는 주장
  - 지수정렬의 난수 비교 방법에는 단점이 존재하며, 예상했던 것보다 약간 더 느리다는 내용

---

- 즉, 이론적으로 기수 정렬은 모든 비교 정렬보다 빠를 수 있다.
  - 그러나 분명히, 컴퓨터 메모리에 수를 저장하는 방식에 대한 제한으로 인해, 실제로는 그렇지 않을 수 있으,
  - 비교 정렬과 마찬가지일 수도 있다


- 그러나 해당 데이터의 특성을 이용하여, 어떤 수든 자릿수에 있는 수를 활용해 직접 비교하지 않고도 분류할 수 있다
  - 무엇이 더 큰지 확인하지 않고, 간단히 버킷( buckets )으로 움직인다음 묶고, 이동하고 , 묶는다