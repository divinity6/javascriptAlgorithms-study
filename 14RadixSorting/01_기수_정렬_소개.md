## Radix Sort

### COMPARISON SORTS

- 지금까지 살펴본 모든 정렬들은 비교 정렬 알고리즘이라는 분류에 속한다


- 즉, 버블정렬이나 퀵 정렬이라도 본질적으로 기본 비교는 두개의 el 을 비교한다
  - 따라서, 하나는 왼쪽, 오른쪽에 있으며 정렬 방식에 따라 어떤 것이 먼저오고 나중에 올지를 결정한다
  - 그러므루, 비교 정렬은 두 개의 el 을 비교한다는 의미이다


- 평균 시간 복잡도
  - Bubble Sort : **O( n^2 )**
  - Insertion Sort : **O( n^2 )**
  - Selection Sort : **O( n^2 )**
  - 개선된 정렬
  - Quick Sort : **O( n log n )**
  - Merge Sort : **O( n log n )**


- 문제는 여기에서 더 빠른 정렬 알고리즘이 있을까?
  - 즉, O( n log n )에서 더 나아질 수 있을까?

---

### CAN WE DO BETTER?

- 정답은 더 나아질 수는 있다.


- 단, 비교를 통해 더 나아질 수 있는 것은 아니다
  - 따라서, 비교 정렬 알고리즘들은 대부분 느리다
  - 비교 정렬 시 최상의 평균 케이스에서 기대할 수 있는 시간 복잡도는 n log n 이다
  - 즉, 단일 비교로는 수학적인 제약이 존재한다


- 그러나 특정 케이스에서는 방법이 있다


- 비교 알고리즘이 아닌, 정렬 알고리즘 유형이 존재한다
  - ( 이런 알고리즘은 데이터의 속성을 이용한다 )
  - 예를 들어, 정수 정렬 알고리즘이 있다면 정수로만 수행된다


- Radix sort 는 직접 비교를 하지 않는다
  - 직접 비교를 하지 않는다는 의미는 이숫자가 이숫자보다 큰가?작은가?등의 비교를 하지 않는다는 의미다
  - 따라서, 기수 정렬( Radix sort )은 지금까지 다룬것과 매우 다르다

---

### RADIX SORT

- 비교를 수행하지 않는 특별한 정렬 알고리즘이고, 숫자로 작동한다


- 보통 실제로 사용할때는 이진법으로 작동한다
  - ( 어떤 숫자, 문자열, 이미지든 이진법으로 표현할 수 있다 )
  - 따라서 어떤 데이터든 정렬할 수 있다


- 그러나 정렬할때 사용할 실제 데이터는 숫자여야 한다


- 두 el 을 가지고 비교하지 않는다
  - ( 무엇이 더 작은지, 큰지 묻지않는다 )


- 그대신, 숫자 크기에 대한 정보를 자릿수로 인코딩한다는 사실을 이용한다
  - 즉, 자릿수가 더 큰 수 가 존재한다면,( 예를 들어 네자리 수 ) 자릿수가 더 작은수( 예를 들어 두 자리 수 )보다 더 크다는 이야기이다


- 두 숫자를 직접 비교하지 않고, 자릿수가 더 많은 수가 더 작은 수보다 크다는 사실을 이용한다

---

### How does it work?

- 십진법으로 비교를한다.


- 1의 자릿수부터 0~9 까지의 바구니안에 해당되는 el 들을 순서대로 넣는다


- 그 값들을 순서대로 바구니에서 꺼내 배열에 넣는다


- 그다음 10의 자릿수를 진행하고,


- 그다음 자릿수로 쭉 진행한다...


- 즉 , 위의 방식은 각각의 el 들을 직접 비교하지는 않는다


- 대신 숫자의특별한 속성을 이용한 것 뿐이다

---

- 현재는 10 진수를 다루기때문에 10 개의 바구니가 존재하는 것이고,


- 7 진수나 2진수를 다룬다면 바구니가 7개 , 2개일 것이다.


- 이렇게 작성하려면, 수에서 해당 위치의 숫자를 알 수 있어야 한다.
  - 예를 들어, 이 수의 두 번째 자리가 뭐지?
  - 네 번째 자리, 첫 번째 자리가 뭐지? 등

---

이것이 Radix Sort( 기수 정렬 )이다


비교 정렬이 아닌 특수한 경우의 정렬 알고리즘이다
( 비교 정렬에 비해 빠르게 수를 정렬할 수 있다 )