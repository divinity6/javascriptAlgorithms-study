## Big O of Singly Linked Lists

단일 연결 리스트

### Insertion : **O( 1 )**

- 단지, 새로운 Node 를 생성해서 현재 Node 와 새로 생성된 Node 의 next 를 업데이트 하면 된다
  - ( 맨 앞에 있던, 맨 뒤에 있던 작업시간은 같다 )


- 반면, Array 의 경우 100 만개의 list 가 있을 경우, index 0 번째에 뭔가를 추가하려 할 경우,


- Array 전체의 index 모두를 1씩 100 만번 이동해야 한다


- 물론, 맨 마지막에 삽입하는 경우에는 일정한 시간만 소요된다


- 즉, 데이터 삽입에 관해서는 **Singly Linked Lists** 가 절대적으로 유리하다

---

### Removal : **O( 1 ) or O( n )**

- 노드가 어디에 위치하느냐에 따라 다르다.


- 리스트의 맨 앞에서 제거한다면 O( 1 ), 즉, 상수시간이 소요된다


- 반면, 맨 마지막 Node 를 제거하는 것은 상당히 어려운 작업이다


- 마지막 Node 인 tail 의 이전 Node 를 찾아야하기 때문에 전체 리스트를 순회해야 한다 


- 따라서, 리스트 맨앞에서 제거하는 최상의 경우는 O( 1 )이고, 맨 마지막에서 제거하는 최악의 경우에는 O( n )이다 

---

### Searching : **O( n )**

- 해당 node 가 마지막에서 두 번째 일수도 있기 때문에 최악의 경우는 O( n )이 된다


- 따라서, list 의 길이가 증가할 경우 검색 작업의 분량도 그만큼 증가한다

---

### Access : **O( n )**

- 특정 node 의 값을 가져오기 위한 작업도 마찬가지다


- 100 만개의 Node 중 100 번째 Node 를 요청하는 경우에도 


- 리스트의 크기가 증가하게 되면 작업량 역시 그에 비례해서 증가하게 된다


- 반면, Array 의 경우에는 임의의 접근이 가능하기 때문에 접근하려는 Node 의


- Index 만 알고 있다면, 일정한 작업 시간만 소요된다

---

- 즉, Array 에서 index 를 관리하는 작업, 삽입 ,제거 작업은 시간이 소요되는 반면,
- Array 의 index 를 이미 알고 있는 Node 에 접근하는 경우에 있어서는 Array 의 구조적인 특징으로 인해
- 일정한 시간만 소요된다

---

### 정리

- **Singly Linked Lists** 는 **삽입, 삭제** 의 경우 Array 에 비해 우수하다


- 즉, 삽입, 삭제 작업을 주로하거나, 임의의 접근 작업이 필요 없거나, 주어진 순서대로 데이터를 관리할 필요가 있을 경우에는 적절하다

---

### RECAP

- 삽입 작업과 list 맨 앞 Node 제거 작업등이 빈번하게 사용될 경우  **Singly Linked Lists** 는 훌륭한 대안이 될 수 있다
  - ( Array 도 맨 마지막에 삽입, 제거는 쉽다 )


- Array 는 내장된 index 를 가지고 있는 반면, **Singly Linked Lists** 는 그렇지 않다
  - Singly Linked Lists 는 다음 Node 로 연결되는 참조, 포인터를 갖는 Node 들의 집합체이다
  - 즉, index or 위치 정보가 없다( index 를 이용해 Node 에 쉽게 접근할 수 없다 )

  
- Stack , Queue 등의 자료구조를 구현하기 위해서는 Singly Linked Lists 에 대한 이해가 필요하다