## Big O of Recursion


- 재귀적 솔루션은 성능이 좋지 않다. 매우 느리다


- fib( n ) 에서 n 이 커질수록 2 배로 커진다


- 계산해야하는 tree 자체가 커진다


- 즉, **O( 2^n )** 이다
  - 매우매우매우 좋지 않다( Not good )
  - 2 의 n 제곱이란 뜻이다
  - n^2 보다 2배이상 안좋다


- 지금까지는 n^2 이 가장 나쁘고 느린 알고리즘의 대명사였지만,
  - 심지어 이건 2의 n 제곱이다.
  - ( 물론, 팩토리얼 정도까지는 아니다. 그러나 전혀 좋지 않다 )


- 정확하게는 1.6 의 n 제곱이지만, 빅오에서는 **O( 2^n )** 으로 축약해서 부른다


- 궁금하면 브라우저에서 fib( 45 )를 해보면 얼마나 시간이 걸리는지 볼 수 있다( 말도안되게 오래걸림 )

---

### WHAT CAN WE IMPROVE??

- O( 2^n )


- 위의 시간복잡도를 개선할 수 있는 방법 2가지를 배워보겠다


- 가장 큰 문제는 반복을 계속 한다는 것이다


- 앞에서 했던 계산들을 기억해두지 않는다


- 하위문제들이 존재하고 겹치는것들도 있기 때문에 동적 프로그래밍을 적용할 수 있다

---

### WHAT IF WE COULD "REMEMBER" OLD VALUES?

- 그렇지만 앞에서 했던 계산들을 기억해 둔다면 어떨까?


- 이것이 동적 프로그래밍의 핵심이다


- 각각의 문제들을 한번씩만 풀고, 그 해답을 저장해서 다시 사용하도록 한다


