### Tabulation

- 메모이제이션은 동적 프로그라밍에 필요한 한가지 특성이었다


- 동적 프로그라밍의 핵심은 한가지 문제를 풀 때, 해당 문제를 더 작은 하위 문제들로 나누고, 


- 각각을 한 번 이상 풀어야 할 때, 앞에서 계산한 값을 저장해서 같은 하위 문제를 계속해서 풀지 않는것이다

---

### TOP-DOWN

- 우리가 한 방식은 하향식 방법에 가까웠다


- 만약, fib( 7 )을 구해야한다면, fib( 6 )부터 시작해서, 


- 기반조건인 fib( 2 ) , fib( 1 )에 도달할때까지 내려가는 것이다


- 즉, 찾으려고 하는 값에서 시작해서 아래로 내려가면서 빈칸을 채운 후 모든 값을 더하는 것이다( 하향식 )

---

### BOTTOM-UP

- 그 반대의 방법이 상향식이다


- 상향식은 fib( 1 ) 과 fib( 2 )에서 시작해 이값들을 더하면서 올라간다


- 결과는 같지만, 다른 방향으로 작업을 하는것 뿐이다

---

### TABULATION

- 해당 전략을 타뷸레이션 전략이라고 한다


- 따라서, 메모이제이션과 타뷸레이션은 동적 프로그라밍의 두 가지 방식이다
  - ( cache 에 값을 저장하는 메모이제이션과 , list 에 값을 저장하는 타뷸레이션 )


- 타뷸레이션에서는 보통 loop 와 같이 순환을 통해서 작업한다


- 무엇이든간에 맨 밑의 바닥에서 시작한다
  - ( 가장 작은 하위 문제를 푼 후 그 결과를 테이블에 저장한다 )
  - 그래서 용어가 타뷸레이션( Tabulation 이다 )
  - 보통은 배열을 사용


- 배열에 데이터를 저장하고, loop 를 돌면서, 앞으로 나아가며 덧셈을 하는 것이다


- 덧셈을 반복해서 얻고자하는 숫자를 얻을때까지 반복하는 것이다


- 재귀는 공간복잡도에서는 조금 까다로울 수 있지만, 타뷸레이션은 공간에 있어서는 제약을 덜 받는 편이다

---

### TABULATED VERSION

````javascript
      /**  
       * - 이거 내가 작성했던 로직을 그냥 loop 문으로 바꾼거네 ㅋㅋㅋ
       * 
       * - 이게 훨씬 직관적이고 알아보기 편하구만 
       * */
     function fib( n ){
        if ( 2 >= n ){
            return 1;
        }
        var fibNames = [ 0 , 1 , 1 ];
        
        for ( var i = 3; i <= n; i++ ){
            fibNames[ i ] = fibNames[ i - 1 ] + fibNames[ i - 2 ];
        }
        return fibNames[ n ];
     }
     
````

- 내가 작성한 솔루션을 그냥 loop 버전으로 바꾼것처럼 보임


- 즉, 결론적으로 가장 간단한 문제( 맨 아래 1 + 2 )부터 시작해서 가장 복잡한 문제인 맨 위까지 올라가는 것이다


- 기존의 메모이제이션 방식으로 풀 경우,


- 메모이제이션의 경우 재귀호출을 하므로, 10000 번 정도의 값을 구하려고하면 Maximum call stack size exceeded 오류( 최대 호출 스택 크기 초과 )를 만나게된다


- 반대로 타뷸레이션의 경우, 10000 번 정도의 값을 구하게 되면 JS 에서는 큰 숫자를 저장할 수 없기 때문에 Infinity 를 반환하게 된다


- 그러나 Infinity 를 반환하는 것은 JS 의 특징일 뿐이고, 다른 언어라면 정확한 값을 반환할 것이다
  - ( 다른 언어더라도, 메모이제이션 방식으로 하게되면 역시나 stack overflow 오류를 발생시킬 것이다 )


- 결론적으로 시간 복잡도에 관련해서는 둘 다 Big **O( n )** 의 값을 가진다