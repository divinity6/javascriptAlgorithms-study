## WTF IS DYNAMIC PROGRAMMING

- 동적 프로그라밍은 문제를 더 작은 조각으로 나눈다음 
- 앞에 위치한 조각을 기억하는 것을 통해 해야하는 작업의 양을 줄이는 방식으로
- 문제를 푸는 접근법이다


- 언제 이방법을 사용할 수 있는 것인가?

---

### IT ONLY WORKS ON PROBLEMS WITH...

- 동적 프로그라밍을 사용할 수 있는지를 확인하기 위해서는 두가지를 체크해야 한다


1. OPTIMAL SUBSTRUCTURE
  - 최적 부분 구조가 존재하는지 여부
  

2. OVERLAPPING SUBPROBLEMS
   - 반복되는 하위문제가 존재하는지 여부
   
---

### OVERLAPPING SUBPROBLEMS : 반복되는 하위 문제

- 주어진 문제에 동적 프로그라밍을 사용하기 위해서는 그 문제에 
- 어떤 방식으로든 중첩되는 하위 문제들이 있어야 한다


- 즉, 한 문제를 더 작은 문제로 나눌 수 있고, 그 조각들 중 일부가 재활용 가능하다는 뜻이다
  - 여러번 재사용 가능해야 한다


#### FIBONACCI SEQUENCE : 피보나치 수열

- 피보나치 수열은 동적 프로그라밍을 사용해서 해결할 수 있는데, 반복되는 하위문제들을 가지고 있다


- 피보나치 수열 : 모든 숫자가 그 앞에 오는 두개의 숫자의 합과 같은 숫자의 열
  - 기본적으로는 1, 1 로 시작 (  0 , 1 로 시작할 때도 있다 )


- 어찌됐든 바로앞에 오는 두개의 숫자의 합이 그다음 숫자가 되는 것이다
  - 예) 1 , 1 , 2( 1 + 1 ) , 3( 1  + 2 )


- 한 문제를 작은 문제로 쪼갤때는 보통 재귀를 통해 처리한다
  - 문제가 반복된다는 표현을 사용하는 경우, 반복되는 것 즉, 하위 문제가 반복되는지 봐야한다


- 예를 들어,
  - 5번째 파보나치 수( fib( 5 ) )를 찾는다고할때 fib( 4 )와 fib( 3 ) 을 구해야 한다
  - 그런데, fib( 3 )을 찾는 로직이 중복된다
  - 만약 fib( 100 )을 찾는다면 하위 문제들의 반복이 심해질 것이다


----

### MERGESORT : 합병 정렬

- 합병 정렬에서는 배열이 있으면 더 작은 조각으로 나누어 정렬하고, 다시 합쳤다

````javascript
                            /** 합병 정렬 */
                            mergeSort( [ 10 , 24 , 76 , 73 ] );
                         /** 분할 하여 정렬 */
            mergeSort( [ 10 , 24 ] );                   mergeSort( [ 76 , 73 ] );
        
      mergeSort( [ 10 ] );  mergeSort( [ 24 ] );    mergeSort( [ 76 ] );   mergeSort( [ 73 ] );
     
````

- 합병정렬도 문제들이 존재한다


- 더 큰 문제를 가지고 더 작은 조각으로 쪼개기는 하지만, 중첩되지는 않는다 


- 같은것을 반복하지 않는다


- 이 반복을 환원할 수 있는 방법도 없다


- 위의 예시를 보면 매번 다른 값을 가진 조각들을 정렬하고 있다
  - ( 즉, 이경우에는 겹치지않는 문제들이다 )
  - 반복되지 않는 하위문제들인 것이다


- 이런 구조는 보통 분할 점령 방식 및 패턴으로 해결된다


- 그러나 동적 프로그라밍에서 사용할 수 없는 문제다
  - ( 반복되는 하위 문제들이 필요하므로... )

---

### MERGESORT A VERY SPECIAL CASE : 합병 정렬의 특별한 케이스

- 합병 정렬에서 반복되는 문제들이 나오는 특별한 케이스

````javascript
                            /** 합병 정렬 */
                            mergeSort( [ 10 , 24 , 10 , 24 ] );
                         /** 분할 하여 정렬 */
            mergeSort( [ 10 , 24 ] );                   mergeSort( [ 10 , 24 ] );
        
      mergeSort( [ 10 ] );  mergeSort( [ 24 ] );    mergeSort( [ 10 ] );   mergeSort( [ 24 ] );
     
````

- 위의 예시 처럼 배열의 특정 구간들이 똑같이 반복된다면 동적 프로그라밍을 사용할 수 있다

---

즉, 반복되는 하위문제란 문제를 더 작은 조각들로 나누는데 그 문제들이 어딘가 겹치는 것들이다